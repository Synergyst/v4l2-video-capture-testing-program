#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <inttypes.h>
#include <fcntl.h>
#include <ctype.h>
#include <errno.h>
#include <sys/ioctl.h>

#include "v4l2-ctl.h"

#include <linux/v4l2-subdev.h>
// The 24-bit IEEE Registration Identifier for the HDMI-LLC Vendor Specific Data Block.
#define HDMI_VSDB_EXT_TAG	0x000c03
 // The 24-bit IEEE Registration Identifier for the HDMI-Forum Vendor Specific Data Block.
#define HF_VSDB_EXT_TAG		0xc45dd8
#define VID_CAP_EXT_TAG		0
#define COLORIMETRY_EXT_TAG	5
#define HDR_MD_EXT_TAG		6
#define VSDB_TAG		3
#define EXTENDED_TAG		7
enum format {
	HEX,
	RAW,
	CARRAY
};
static struct v4l2_edid sedid;
static char* file_in;
static struct v4l2_edid gedid;
static struct v4l2_edid info_edid;
static char* file_out;
static enum format gformat;
static enum format sformat;
static unsigned clear_pad;
static long phys_addr = -1;
static __u8 toggle_cta861_hdr_flags;
#define CTA861_HDR_UNDERSCAN   (1 << 6)
#define CTA861_HDR_AUDIO	     (1 << 6)
#define CTA861_HDR_YCBCR444    (1 << 5)
#define CTA861_HDR_YCBCR422    (1 << 4)
static __u8 toggle_hdmi_vsdb_dc_flags;
#define HDMI_VSDB_Y444_BIT     (1 << 3)
#define HDMI_VSDB_30_BIT       (1 << 4)
#define HDMI_VSDB_36_BIT       (1 << 5)
#define HDMI_VSDB_48_BIT       (1 << 6)
static __u8 toggle_hdmi_vsdb_cnc_flags;
#define HDMI_VSDB_GRAPHICS     (1 << 0)
#define HDMI_VSDB_PHOTO        (1 << 1)
#define HDMI_VSDB_CINEMA       (1 << 2)
#define HDMI_VSDB_GAME         (1 << 3)
#define HDMI_VSDB_I_LATENCY    (1 << 6)
#define HDMI_VSDB_LATENCY      (1 << 7)
static __u8 toggle_hf_vsdb_flags;
#define HF_VSDB_SCSD_PRESENT   (1 << 7)
static int mod_s_pt = -1;
static int mod_s_it = -1;
static int mod_s_ce = -1;
static __u8 toggle_vid_cap_flags;
#define VID_CAP_QS             (1 << 6)
#define VID_CAP_QY             (1 << 7)
static __u8 toggle_colorimetry_flags1;
#define COLORIMETRY_XVYCC601   (1 << 0)
#define COLORIMETRY_XVYCC709   (1 << 1)
#define COLORIMETRY_SYCC       (1 << 2)
#define COLORIMETRY_ADOBEYCC   (1 << 3)
#define COLORIMETRY_ADOBERGB   (1 << 4)
#define COLORIMETRY_BT2020CYCC (1 << 5)
#define COLORIMETRY_BT2020YCC  (1 << 6)
#define COLORIMETRY_BT2020RGB  (1 << 7)
static __u8 toggle_colorimetry_flags2;
#define COLORIMETRY_DCIP3      (1 << 0)
static __u8 toggle_hdr_md_flags;
#define HDR_MD_SDR             (1 << 0)
#define HDR_MD_HDR             (1 << 1)
#define HDR_MD_SMPTE_2084      (1 << 2)
#define HDR_MD_HLG             (1 << 3)

int doioctl(int fh, int request, void* arg) {
	int r;
	do {
		r = ioctl(fh, request, arg);
	} while (-1 == r && EINTR == errno);
	return r;
}

static void edid_add_block(struct v4l2_edid* e) {
	e->blocks++;
	if (e->blocks > 256) {
		fprintf(stderr, "edid file error: too long\n");
		free(e->edid);
		e->edid = NULL;
		exit(1);
	}
	e->edid = (unsigned char*)realloc(e->edid, e->blocks * 128);
}

static void read_edid_file(FILE* f, struct v4l2_edid* e) {
	char value[3] = { 0 };
	unsigned i = 0;
	int c;
	fseek(f, SEEK_SET, 0);
	e->edid = NULL;
	e->blocks = 0;
	while ((c = fgetc(f)) != EOF) {
		if (sformat == RAW) {
			if (i % 256 == 0)
				edid_add_block(e);
			e->edid[i / 2] = c;
			i += 2;
			continue;
		}
		// Handle '0x' prefix
		if ((i & 1) && value[0] == '0' && (c == 'x' || c == 'X'))
			i--;
		if (!isxdigit(c))
			continue;
		if (i & 0x01) {
			value[1] = c;
			if (i % 256 == 1)
				edid_add_block(e);
			e->edid[i / 2] = strtoul(value, 0, 16);
		} else {
			value[0] = c;
		}
		i++;
	}
}

static unsigned char crc_calc(const unsigned char* b) {
	unsigned char sum = 0;
	int i;
	for (i = 0; i < 127; i++)
		sum += b[i];
	return 256 - sum;
}

static bool crc_ok(const unsigned char* b) {
	return crc_calc(b) == b[127];
}

static void fix_edid(struct v4l2_edid* e) {
	for (unsigned b = 0; b < e->blocks; b++) {
		unsigned char* buf = e->edid + 128 * b;
		if (!crc_ok(buf))
			buf[127] = crc_calc(buf);
	}
}

static bool verify_edid(struct v4l2_edid* e) {
	bool valid = true;
	for (unsigned b = 0; b < e->blocks; b++) {
		const unsigned char* buf = e->edid + 128 * b;
		if (!crc_ok(buf)) {
			fprintf(stderr, "Block %u has a checksum error (should be 0x%02x)\n", b, crc_calc(buf));
			valid = false;
		}
	}
	return valid;
}

static void hexdumpedid(FILE* f, struct v4l2_edid* e) {
	for (unsigned b = 0; b < e->blocks; b++) {
		unsigned char* buf = e->edid + 128 * b;
		if (b)
			fprintf(f, "\n");
		for (unsigned i = 0; i < 128; i += 0x10) {
			fprintf(f, "%02x", buf[i]);
			for (unsigned j = 1; j < 0x10; j++) {
				fprintf(f, " %02x", buf[i + j]);
			}
			fprintf(f, "\n");
		}
		if (!crc_ok(buf))
			fprintf(f, "Block %u has a checksum error (should be 0x%02x)\n", b, crc_calc(buf));
	}
}

static void rawdumpedid(FILE* f, struct v4l2_edid* e) {
	for (unsigned b = 0; b < e->blocks; b++) {
		unsigned char* buf = e->edid + 128 * b;
		for (unsigned i = 0; i < 128; i++)
			fprintf(f, "%c", buf[i]);
		if (!crc_ok(buf))
			fprintf(stderr, "Block %u has a checksum error (should be %02x)\n", b, crc_calc(buf));
	}
}

static void carraydumpedid(FILE* f, struct v4l2_edid* e) {
	fprintf(f, "unsigned char edid[] = {\n");
	for (unsigned b = 0; b < e->blocks; b++) {
		unsigned char* buf = e->edid + 128 * b;
		if (b)
			fprintf(f, "\n");
		for (unsigned i = 0; i < 128; i += 8) {
			fprintf(f, "\t0x%02x,", buf[i]);
			for (unsigned j = 1; j < 8; j++) {
				fprintf(f, " 0x%02x,", buf[i + j]);
			}
			fprintf(f, "\n");
		}
		if (!crc_ok(buf))
			fprintf(f, "\t/* Block %u has a checksum error (should be 0x%02x) */\n", b, crc_calc(buf));
	}
	fprintf(f, "};\n");
}

static int get_edid_tag_location(const unsigned char* edid, unsigned size, unsigned char want_tag, __u32 ext_tag) {
	unsigned char d;
	if (size < 256)
		return -1;
	if (edid[0x7e] != 1 || edid[0x80] != 0x02 || edid[0x81] != 0x03)
		return -1;
	// search tag
	d = edid[0x82] & 0x7f;
	if (d <= 4)
		return -1;
	int i = 0x84;
	int end = 0x80 + d;
	do {
		unsigned char tag = edid[i] >> 5;
		unsigned char len = edid[i] & 0x1f;
		if (tag != want_tag || i + len > end) {
			i += len + 1;
			continue;
		}
		// Tag 3 (Vendor-Specific Data Block) has a 24 bit IEEE identifier.
		if (tag == VSDB_TAG && len >= 3 &&
			edid[i + 1] == (ext_tag & 0xff) &&
			edid[i + 2] == ((ext_tag >> 8) & 0xff) &&
			edid[i + 3] == ((ext_tag >> 16) & 0xff))
			return i;
		// Tag 7 has an extended tag, others (0-2, 4-6) have no identifiers.
		if ((tag < EXTENDED_TAG && tag != VSDB_TAG) || (tag == EXTENDED_TAG && len >= 1 && edid[i + 1] == ext_tag))
			return i;
		i += len + 1;
	} while (i < end);
	return -1;
}

static int get_edid_spa_location(const unsigned char* edid, unsigned size) {
	int loc = get_edid_tag_location(edid, size, VSDB_TAG, HDMI_VSDB_EXT_TAG);
	if (loc < 0)
		return loc;
	return (edid[loc] & 0x1f) >= 5 ? loc + 4 : -1;
}

static void set_edid_phys_addr(unsigned char* edid, unsigned size, unsigned short phys_addr) {
	int loc = get_edid_spa_location(edid, size);
	unsigned char sum = 0;
	int i;
	if (loc < 0)
		return;
	edid[loc] = phys_addr >> 8;
	edid[loc + 1] = phys_addr & 0xff;
	loc &= ~0x7f;
	for (i = loc; i < loc + 127; i++)
		sum += edid[i];
	edid[i] = 256 - sum;
}

static unsigned short parse_phys_addr(const char* value) {
	unsigned p1, p2, p3, p4;
	if (!strchr(value, '.'))
		return strtoul(value, NULL, 0);
	if (sscanf(value, "%x.%x.%x.%x", &p1, &p2, &p3, &p4) != 4) {
		fprintf(stderr, "Expected a physical address of the form x.x.x.x\n");
		return 0xffff;
	}
	if (p1 > 0xf || p2 > 0xf || p3 > 0xf || p4 > 0xf) {
		fprintf(stderr, "Physical address components should never be larger than 0xf\n");
		return 0xffff;
	}
	return (p1 << 12) | (p2 << 8) | (p3 << 4) | p4;
}

static uint8_t vga_edid[128] = {
	0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
	0x31, 0xd8, 0x34, 0x12, 0x00, 0x00, 0x00, 0x00,
	0x22, 0x1a, 0x01, 0x04, 0x08, 0x30, 0x1e, 0x78,
	0x0f, 0xee, 0x91, 0xa3, 0x54, 0x4c, 0x99, 0x26,
	0x0f, 0x50, 0x54, 0x2f, 0xcf, 0x00, 0x31, 0x59,
	0x45, 0x59, 0x61, 0x59, 0x81, 0x40, 0x81, 0x80,
	0x95, 0x00, 0xa9, 0x40, 0xb3, 0x00, 0x28, 0x3c,
	0x80, 0xa0, 0x70, 0xb0, 0x23, 0x40, 0x30, 0x20,
	0x36, 0x00, 0xe0, 0x2c, 0x11, 0x00, 0x00, 0x1a,
	0x00, 0x00, 0x00, 0xfd, 0x00, 0x31, 0x55, 0x18,
	0x5e, 0x11, 0x04, 0x12, 0x00, 0xf0, 0xf8, 0x58,
	0xf0, 0x3c, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x76,
	0x67, 0x61, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20,
	0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x10,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xce,
};

static uint8_t dvid_edid[128] = {
	0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
	0x31, 0xd8, 0x34, 0x12, 0x00, 0x00, 0x00, 0x00,
	0x22, 0x1a, 0x01, 0x04, 0xa1, 0x30, 0x1e, 0x78,
	0x07, 0xee, 0x91, 0xa3, 0x54, 0x4c, 0x99, 0x26,
	0x0f, 0x50, 0x54, 0x2f, 0xcf, 0x00, 0x31, 0x59,
	0x45, 0x59, 0x81, 0x80, 0x81, 0x40, 0x90, 0x40,
	0x95, 0x00, 0xa9, 0x40, 0xb3, 0x00, 0x28, 0x3c,
	0x80, 0xa0, 0x70, 0xb0, 0x23, 0x40, 0x30, 0x20,
	0x36, 0x00, 0xe0, 0x2c, 0x11, 0x00, 0x00, 0x1a,
	0x00, 0x00, 0x00, 0xfd, 0x00, 0x18, 0x55, 0x18,
	0x5e, 0x11, 0x04, 0x12, 0x00, 0xf0, 0xf8, 0x58,
	0xf0, 0x3c, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x64,
	0x76, 0x69, 0x2d, 0x64, 0x0a, 0x20, 0x20, 0x20,
	0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x10,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xea,
};

static uint8_t hdmi_edid[256] = {
	0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
	0x31, 0xd8, 0x34, 0x12, 0x00, 0x00, 0x00, 0x00,
	0x22, 0x1a, 0x01, 0x03, 0x80, 0x30, 0x1b, 0x78,
	0x0f, 0xee, 0x91, 0xa3, 0x54, 0x4c, 0x99, 0x26,
	0x0f, 0x50, 0x54, 0x2f, 0xcf, 0x00, 0x31, 0x59,
	0x45, 0x59, 0x81, 0x80, 0x81, 0x40, 0x90, 0x40,
	0x95, 0x00, 0xa9, 0x40, 0xb3, 0x00, 0x02, 0x3a,
	0x80, 0x18, 0x71, 0x38, 0x2d, 0x40, 0x58, 0x2c,
	0x45, 0x00, 0xe0, 0x0e, 0x11, 0x00, 0x00, 0x1e,
	0x00, 0x00, 0x00, 0xfd, 0x00, 0x18, 0x55, 0x18,
	0x5e, 0x11, 0x00, 0x0a, 0x20, 0x20, 0x20, 0x20,
	0x20, 0x20, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x68,
	0x64, 0x6d, 0x69, 0x0a, 0x20, 0x20, 0x20, 0x20,
	0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x10,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc4,

	0x02, 0x03, 0x2d, 0xf0, 0x4c, 0x10, 0x1f, 0x04,
	0x13, 0x22, 0x21, 0x20, 0x05, 0x14, 0x02, 0x11,
	0x01, 0x23, 0x09, 0x07, 0x07, 0x83, 0x01, 0x00,
	0x00, 0x68, 0x03, 0x0c, 0x00, 0x10, 0x00, 0x00,
	0x22, 0x01, 0xe2, 0x00, 0xea, 0xe3, 0x05, 0x00,
	0x00, 0xe3, 0x06, 0x01, 0x00, 0x1a, 0x36, 0x80,
	0xa0, 0x70, 0x38, 0x1f, 0x40, 0x30, 0x20, 0x35,
	0x00, 0xe0, 0x0e, 0x11, 0x00, 0x00, 0x1a, 0x1a,
	0x1d, 0x00, 0x80, 0x51, 0xd0, 0x1c, 0x20, 0x40,
	0x80, 0x35, 0x00, 0xe0, 0x0e, 0x11, 0x00, 0x00,
	0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7d,
};

static uint8_t hdmi_edid_4k_170[256] = {
	0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
	0x31, 0xd8, 0x34, 0x12, 0x00, 0x00, 0x00, 0x00,
	0x22, 0x1a, 0x01, 0x03, 0x80, 0x60, 0x36, 0x78,
	0x0f, 0xee, 0x91, 0xa3, 0x54, 0x4c, 0x99, 0x26,
	0x0f, 0x50, 0x54, 0x2f, 0xcf, 0x00, 0x31, 0x59,
	0x45, 0x59, 0x81, 0x80, 0x81, 0x40, 0x90, 0x40,
	0x95, 0x00, 0xa9, 0x40, 0xb3, 0x00, 0x02, 0x3a,
	0x80, 0x18, 0x71, 0x38, 0x2d, 0x40, 0x58, 0x2c,
	0x46, 0x00, 0xc0, 0x1c, 0x32, 0x00, 0x00, 0x1e,
	0x00, 0x00, 0x00, 0xfd, 0x00, 0x18, 0x55, 0x18,
	0x5e, 0x11, 0x00, 0x0a, 0x20, 0x20, 0x20, 0x20,
	0x20, 0x20, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x68,
	0x64, 0x6d, 0x69, 0x2d, 0x34, 0x6b, 0x2d, 0x31,
	0x37, 0x30, 0x0a, 0x20, 0x00, 0x00, 0x00, 0x10,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xb8,

	0x02, 0x03, 0x32, 0xf0, 0x4c, 0x10, 0x1f, 0x04,
	0x13, 0x22, 0x21, 0x20, 0x05, 0x14, 0x02, 0x11,
	0x01, 0x23, 0x09, 0x07, 0x07, 0x83, 0x01, 0x00,
	0x00, 0x68, 0x03, 0x0c, 0x00, 0x10, 0x00, 0x00,
	0x22, 0x01, 0xe2, 0x00, 0xea, 0xe4, 0x0e, 0x5f,
	0x5e, 0x5d, 0xe3, 0x05, 0x00, 0x00, 0xe3, 0x06,
	0x01, 0x00, 0x1a, 0x36, 0x80, 0xa0, 0x70, 0x38,
	0x1f, 0x40, 0x30, 0x20, 0x35, 0x00, 0xc0, 0x1c,
	0x32, 0x00, 0x00, 0x1a, 0x1a, 0x1d, 0x00, 0x80,
	0x51, 0xd0, 0x1c, 0x20, 0x40, 0x80, 0x35, 0x00,
	0xc0, 0x1c, 0x32, 0x00, 0x00, 0x1c, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4e,
};

static uint8_t hdmi_edid_4k_300[256] = {
	0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
	0x31, 0xd8, 0x34, 0x12, 0x00, 0x00, 0x00, 0x00,
	0x22, 0x1a, 0x01, 0x03, 0x80, 0x60, 0x36, 0x78,
	0x0f, 0xee, 0x91, 0xa3, 0x54, 0x4c, 0x99, 0x26,
	0x0f, 0x50, 0x54, 0x2f, 0xcf, 0x00, 0x31, 0x59,
	0x45, 0x59, 0x81, 0x80, 0x81, 0x40, 0x90, 0x40,
	0x95, 0x00, 0xa9, 0x40, 0xb3, 0x00, 0x04, 0x74,
	0x00, 0x30, 0xf2, 0x70, 0x5a, 0x80, 0xb0, 0x58,
	0x8a, 0x00, 0xc0, 0x1c, 0x32, 0x00, 0x00, 0x1e,
	0x00, 0x00, 0x00, 0xfd, 0x00, 0x18, 0x55, 0x18,
	0x87, 0x1e, 0x00, 0x0a, 0x20, 0x20, 0x20, 0x20,
	0x20, 0x20, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x68,
	0x64, 0x6d, 0x69, 0x2d, 0x34, 0x6b, 0x2d, 0x33,
	0x30, 0x30, 0x0a, 0x20, 0x00, 0x00, 0x00, 0x10,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc5,

	0x02, 0x03, 0x3d, 0xf0, 0x4f, 0x5f, 0x5e, 0x5d,
	0x10, 0x1f, 0x04, 0x13, 0x22, 0x21, 0x20, 0x05,
	0x14, 0x02, 0x11, 0x01, 0x23, 0x09, 0x07, 0x07,
	0x83, 0x01, 0x00, 0x00, 0x6d, 0x03, 0x0c, 0x00,
	0x10, 0x00, 0x00, 0x3c, 0x21, 0x00, 0x60, 0x01,
	0x02, 0x03, 0x67, 0xd8, 0x5d, 0xc4, 0x01, 0x00,
	0x00, 0x00, 0xe2, 0x00, 0xea, 0xe3, 0x05, 0x00,
	0x00, 0xe3, 0x06, 0x01, 0x00, 0xa3, 0x66, 0x00,
	0xa0, 0xf0, 0x70, 0x1f, 0x80, 0x30, 0x20, 0x35,
	0x00, 0xc0, 0x1c, 0x32, 0x00, 0x00, 0x1e, 0x1a,
	0x36, 0x80, 0xa0, 0x70, 0x38, 0x1f, 0x40, 0x30,
	0x20, 0x35, 0x00, 0xc0, 0x1c, 0x32, 0x00, 0x00,
	0x1a, 0x1a, 0x1d, 0x00, 0x80, 0x51, 0xd0, 0x1c,
	0x20, 0x40, 0x80, 0x35, 0x00, 0xc0, 0x1c, 0x32,
	0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd3,
};

static uint8_t hdmi_edid_4k_600[256] = {
	0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
	0x31, 0xd8, 0x34, 0x12, 0x00, 0x00, 0x00, 0x00,
	0x22, 0x1a, 0x01, 0x03, 0x80, 0x60, 0x36, 0x78,
	0x0f, 0xee, 0x91, 0xa3, 0x54, 0x4c, 0x99, 0x26,
	0x0f, 0x50, 0x54, 0x2f, 0xcf, 0x00, 0x31, 0x59,
	0x45, 0x59, 0x81, 0x80, 0x81, 0x40, 0x90, 0x40,
	0x95, 0x00, 0xa9, 0x40, 0xb3, 0x00, 0x08, 0xe8,
	0x00, 0x30, 0xf2, 0x70, 0x5a, 0x80, 0xb0, 0x58,
	0x8a, 0x00, 0xc0, 0x1c, 0x32, 0x00, 0x00, 0x1e,
	0x00, 0x00, 0x00, 0xfd, 0x00, 0x18, 0x55, 0x18,
	0x87, 0x3c, 0x00, 0x0a, 0x20, 0x20, 0x20, 0x20,
	0x20, 0x20, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x68,
	0x64, 0x6d, 0x69, 0x2d, 0x34, 0x6b, 0x2d, 0x36,
	0x30, 0x30, 0x0a, 0x20, 0x00, 0x00, 0x00, 0x10,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x2c,

	0x02, 0x03, 0x3f, 0xf0, 0x51, 0x61, 0x60, 0x5f,
	0x5e, 0x5d, 0x10, 0x1f, 0x04, 0x13, 0x22, 0x21,
	0x20, 0x05, 0x14, 0x02, 0x11, 0x01, 0x23, 0x09,
	0x07, 0x07, 0x83, 0x01, 0x00, 0x00, 0x6d, 0x03,
	0x0c, 0x00, 0x10, 0x00, 0x00, 0x3c, 0x21, 0x00,
	0x60, 0x01, 0x02, 0x03, 0x67, 0xd8, 0x5d, 0xc4,
	0x01, 0x78, 0x00, 0x00, 0xe2, 0x00, 0xea, 0xe3,
	0x05, 0x00, 0x00, 0xe3, 0x06, 0x01, 0x00, 0x4d,
	0xd0, 0x00, 0xa0, 0xf0, 0x70, 0x3e, 0x80, 0x30,
	0x20, 0x35, 0x00, 0xc0, 0x1c, 0x32, 0x00, 0x00,
	0x1e, 0x1a, 0x36, 0x80, 0xa0, 0x70, 0x38, 0x1f,
	0x40, 0x30, 0x20, 0x35, 0x00, 0xc0, 0x1c, 0x32,
	0x00, 0x00, 0x1a, 0x1a, 0x1d, 0x00, 0x80, 0x51,
	0xd0, 0x1c, 0x20, 0x40, 0x80, 0x35, 0x00, 0xc0,
	0x1c, 0x32, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63,
};

void edid_set(int fd) {
	int loc;
	FILE* fin = NULL;
	bool must_fix_edid = true;
	if (file_in) {
		if (!strcmp(file_in, "-"))
			fin = stdin;
		else
			fin = fopen(file_in, "r");
		if (!fin) {
			fprintf(stderr, "Failed to open %s: %s\n", file_in, strerror(errno));
			exit(1);
		}
	}
	if (fin) {
		read_edid_file(fin, &sedid);
		if (sedid.blocks == 0) {
			fprintf(stderr, "%s contained an empty EDID, ignoring.\n", file_in ? file_in : "stdin");
			exit(1);
		}
	}
	if (must_fix_edid)
		fix_edid(&sedid);
	if (verify_edid(&sedid))
		doioctl(fd, VIDIOC_S_EDID, &sedid);
	else
		fprintf(stderr, "EDID not set due to checksum errors\n");
	if (fin) {
		if (sedid.edid) {
			free(sedid.edid);
			sedid.edid = NULL;
		}
		if (fin != stdin)
			fclose(fin);
	}
}