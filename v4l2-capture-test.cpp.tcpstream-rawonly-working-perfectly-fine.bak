#include <cmath>
#include <vector>
#include <chrono>
#include <cstdio>
#include <future>
#include <popt.h>
#include <atomic>
#include <string>
#include <fcntl.h>
#include <cstring>
#include <cerrno>
#include <cstdlib>
#include <cassert>
#include <unistd.h>
#include <stdexcept>
#include <libv4l2.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/select.h>
#include <linux/videodev2.h>

// Networking
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netinet/tcp.h>
#include <signal.h>

using namespace std;

#define V4L_ALLFORMATS  3
#define V4L_RAWFORMATS  1
#define V4L_COMPFORMATS 2
#define CLEAR(x) memset(&(x), 0, sizeof(x))

int byteScaler = 3, defaultWidth = 1920, defaultHeight = 1080, numPixels = defaultWidth * defaultHeight;
double allDevicesTargetFramerate = 240;
bool isDualInput = false, done = false;
std::atomic<bool> shouldLoop;
std::future<int> background_task_cap_main;
std::future<int> background_task_cap_alt;
std::vector<std::string> devNames;

// TCP server globals
int listenPort = 0;
int listen_fd = -1;
std::vector<int> client_fds;

struct buffer {
  void* start;
  size_t length;
};
struct devInfo {
  int frame_number,
    framerate,
    startingWidth,
    startingHeight,
    startingSize,
    force_format,
    fd;
  unsigned int n_buffers;
  double frameDelayMicros,
    frameDelayMillis,
    targetFrameDelayMicros,
    targetFrameDelayMillis,
    framerateDivisor,
    targetFramerate;
  bool isTC358743 = true,
    realAndTargetRatesMatch = true;
  struct v4l2_requestbuffers req;
  enum v4l2_buf_type type;
  int index;
  unsigned char *outputFrame;
  char* device;
};
struct buffer* buffersMain;
struct buffer* buffersAlt;
struct devInfo* devInfoMain;
struct devInfo* devInfoAlt;

void errno_exit(const char* s) {
  fprintf(stderr, "%s error %d, %s\n", s, errno, strerror(errno));
  exit(EXIT_FAILURE);
}
int xioctl(int fh, int request, void* arg) {
  int r;
  do {
    r = ioctl(fh, request, arg);
  } while (-1 == r && errno == EINTR);
  return r;
}

// helper to trim whitespace from tokens (local to this file)
static inline std::string trim_copy(const std::string& s) {
    const char* ws = " \t\r\n";
    const auto b = s.find_first_not_of(ws);
    if (b == std::string::npos) return std::string();
    const auto e = s.find_last_not_of(ws);
    return s.substr(b, e - b + 1);
}

// Networking helpers
static int set_nonblocking(int fd) {
  int flags = fcntl(fd, F_GETFL, 0);
  if (flags < 0) return -1;
  if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) < 0) return -1;
  return 0;
}
static int setup_server_socket(int port) {
  signal(SIGPIPE, SIG_IGN); // Avoid SIGPIPE on send() to disconnected clients
  int fd = socket(AF_INET, SOCK_STREAM, 0);
  if (fd < 0) {
    perror("[net] socket");
    return -1;
  }
  int one = 1;
  setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one));
  if (set_nonblocking(fd) < 0) {
    perror("[net] set_nonblocking(listen)");
    close(fd);
    return -1;
  }
  sockaddr_in addr;
  memset(&addr, 0, sizeof(addr));
  addr.sin_family = AF_INET;
  addr.sin_addr.s_addr = htonl(INADDR_ANY);
  addr.sin_port = htons((uint16_t)port);
  if (bind(fd, (sockaddr*)&addr, sizeof(addr)) < 0) {
    perror("[net] bind");
    close(fd);
    return -1;
  }
  if (listen(fd, 16) < 0) {
    perror("[net] listen");
    close(fd);
    return -1;
  }
  fprintf(stderr, "[net] Listening on port %d\n", port);
  return fd;
}
/*static void accept_new_clients() {
  while (true) {
    sockaddr_in cliaddr;
    socklen_t len = sizeof(cliaddr);
    int cfd = accept(listen_fd, (sockaddr*)&cliaddr, &len);
    if (cfd < 0) {
      if (errno == EAGAIN || errno == EWOULDBLOCK) break;
      perror("[net] accept");
      break;
    }
    set_nonblocking(cfd);
    int one = 1;
    setsockopt(cfd, IPPROTO_TCP, TCP_NODELAY, &one, sizeof(one));
    client_fds.push_back(cfd);
    char ip[64]; inet_ntop(AF_INET, &cliaddr.sin_addr, ip, sizeof(ip));
    fprintf(stderr, "[net] Client connected: %s:%d (fd=%d). Total clients: %zu\n", ip, ntohs(cliaddr.sin_port), cfd, client_fds.size());
  }
}
static bool send_all_or_drop(int fd, const unsigned char* data, size_t len) {
  size_t sent = 0;
  while (sent < len) {
    ssize_t n = send(fd, data + sent, len - sent, MSG_NOSIGNAL);
    if (n > 0) { sent += (size_t)n; continue; }
    if (n < 0 && errno == EINTR) continue;
    if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
      // Too slow; consider as dropped for simplicity
      return false;
    }
    // Other error: disconnect
    return false;
  }
  return true;
}
static void broadcast_frame(const unsigned char* data, size_t len) {
  if (client_fds.empty()) return;
  // Send to all clients; drop slow/disconnected ones
  for (size_t i = 0; i < client_fds.size();) {
    int fd = client_fds[i];
    if (!send_all_or_drop(fd, data, len)) {
      fprintf(stderr, "[net] Dropping client fd=%d\n", fd);
      close(fd);
      client_fds.erase(client_fds.begin() + i);
      continue;
    }
    ++i;
  }
}*/

// Keep listening socket non-blocking if you like, but leave clients blocking.
static void accept_new_clients() {
  while (true) {
    sockaddr_in cliaddr;
    socklen_t len = sizeof(cliaddr);
    int cfd = accept(listen_fd, (sockaddr*)&cliaddr, &len);
    if (cfd < 0) {
      if (errno == EAGAIN || errno == EWOULDBLOCK) break;
      perror("[net] accept");
      break;
    }
    // Note: do NOT set_nonblocking(cfd);
    int one = 1;
    setsockopt(cfd, IPPROTO_TCP, TCP_NODELAY, &one, sizeof(one));
    // Optional: keepalive
    setsockopt(cfd, SOL_SOCKET, SO_KEEPALIVE, &one, sizeof(one));

    client_fds.push_back(cfd);
    char ip[64]; inet_ntop(AF_INET, &cliaddr.sin_addr, ip, sizeof(ip));
    fprintf(stderr, "[net] Client connected: %s:%d (fd=%d). Total clients: %zu\n",
            ip, ntohs(cliaddr.sin_port), cfd, client_fds.size());
  }
}

static bool send_all_or_drop(int fd, const unsigned char* data, size_t len) {
  size_t sent = 0;
  while (sent < len) {
    ssize_t n = send(fd, data + sent, len - sent, MSG_NOSIGNAL);
    if (n > 0) {
      sent += (size_t)n;
      continue;
    }
    if (n < 0 && errno == EINTR) continue;

    // On blocking sockets, EAGAIN/EWOULDBLOCK should not happen (unless timeouts are set).
    // Treat any other error as a disconnect.
    return false; // drop client
  }
  return true;
}

static void broadcast_frame(const unsigned char* data, size_t len) {
  if (client_fds.empty()) return;
  for (size_t i = 0; i < client_fds.size();) {
    int fd = client_fds[i];
    if (!send_all_or_drop(fd, data, len)) {
      fprintf(stderr, "[net] Dropping client fd=%d\n", fd);
      close(fd);
      client_fds.erase(client_fds.begin() + i);
      continue;
    }
    ++i;
  }
}

// parse optional args and collect device names
void parse_cli_or_die(int argc, const char** argv) {
  double opt_fps = allDevicesTargetFramerate; // default remains the global default
  const char* opt_devices = nullptr;          // optional comma-separated list
  int opt_port = 0;

  struct poptOption optionsTable[] = {
    { "fps",     'f',    POPT_ARG_DOUBLE,   &opt_fps,      0,    "Target framerate for all devices",                        "FPS" },
    { "devices", 'd',    POPT_ARG_STRING,   &opt_devices,  0,    "V4L2 device(s): /dev/video0 or /dev/video0,/dev/video1",  "DEV[,DEV]" },
    { "port",    'p',    POPT_ARG_INT,      &opt_port,     0,    "TCP listen port for streaming frames",                    "PORT" },
    { "help",    'h',    POPT_ARG_NONE,     nullptr,       'h',  "Show help and exit",                                      nullptr },
    { nullptr,   0,      0,                 nullptr,       0,    nullptr,                                                   nullptr }
  };
  poptContext pc = poptGetContext(argv[0], argc, argv, optionsTable, 0);
  int rc;
  while ((rc = poptGetNextOpt(pc)) >= 0) {
    // nothing else to do here; values are written directly to opt variables
  }
  if (rc < -1) {
    fprintf(stderr, "[main] Error parsing options: %s: %s\n", poptBadOption(pc, POPT_BADOPTION_NOALIAS), poptStrerror(rc));
    poptPrintUsage(pc, stderr, 0);
    exit(1);
  }
  // Collect remaining non-option arguments as device names
  devNames.clear();
  if (opt_devices && *opt_devices) {
    std::string list(opt_devices);
    size_t start = 0;
    while (start <= list.size()) {
      size_t pos = list.find(',', start);
      std::string token = (pos == std::string::npos)
                            ? list.substr(start)
                            : list.substr(start, pos - start);
      token = trim_copy(token);
      if (!token.empty()) devNames.emplace_back(token);
      if (pos == std::string::npos) break;
      start = pos + 1;
    }
    const char* extra = nullptr;
    while ((extra = poptGetArg(pc)) != nullptr) {
      fprintf(stderr, "[main] Warning: ignoring extra device '%s' because --devices was specified\n", extra);
    }
  } else {
    const char* arg = nullptr;
    while ((arg = poptGetArg(pc)) != nullptr) {
      devNames.emplace_back(arg);
    }
  }
  poptFreeContext(pc);

  if (devNames.size() == 1) {
    isDualInput = false;
  } else if (devNames.size() == 2) {
    isDualInput = true;
  } else {
    fprintf(stderr, "[main] Usage:\n");
    fprintf(stderr, "  %s [options] --devices=</dev/video0>[,/dev/video1] --port=<PORT>\n", argv[0]);
    fprintf(stderr, "  %s [options] </dev/video0> [/dev/video1] --port=<PORT>\n", argv[0]);
    fprintf(stderr, "Options:\n");
    fprintf(stderr, "  -f, --fps=<FPS>          Target framerate for all devices (default: %.3f)\n", allDevicesTargetFramerate);
    fprintf(stderr, "  -d, --devices=<DEVICE(s)>  Comma-separated devices, e.g. /dev/video0 or /dev/video0,/dev/video1\n");
    fprintf(stderr, "  -p, --port=<PORT>        TCP listen port for streaming frames (required)\n");
    exit(1);
  }
  if (opt_port <= 0 || opt_port > 65535) {
    fprintf(stderr, "[main] Error: valid --port=<1-65535> is required\n");
    exit(1);
  }

  // Apply parsed options to globals
  allDevicesTargetFramerate = opt_fps;
  listenPort = opt_port;

  fprintf(stderr, "[main] Parsed options: --fps=%.3f, --devices=%s%s%s, --port=%d\n",
          allDevicesTargetFramerate,
          devNames[0].c_str(),
          isDualInput ? "," : "",
          isDualInput ? devNames[1].c_str() : "",
          listenPort);
}

bool doubles_equal(double a, double b, double epsilon = 0.001) { return std::fabs(a - b) < epsilon; }

class MicroStopwatch {
    std::chrono::high_resolution_clock::time_point start_time;
public:
    void start() {
        start_time = std::chrono::high_resolution_clock::now();
    }
    double elapsedMicros() const {
        auto now = std::chrono::high_resolution_clock::now();
        std::chrono::duration<double, std::micro> diff = now - start_time;
        return diff.count();
    }
};

int init_dev_stage1(struct buffer*& buffers, struct devInfo*& devInfos) {
  fprintf(stderr, "\n[cap%d] Starting V4L2 capture testing program with the following V4L2 device: %s\n", devInfos->index, devInfos->device);
  struct stat st;
  if (-1 == stat(devInfos->device, &st)) {
    fprintf(stderr, "[cap%d] Cannot identify '%s': %d, %s\n", devInfos->index, devInfos->device, errno, strerror(errno));
    exit(EXIT_FAILURE);
  }
  if (!S_ISCHR(st.st_mode)) {
    fprintf(stderr, "[cap%d] %s is no device\n", devInfos->index, devInfos->device);
    exit(EXIT_FAILURE);
  }
  devInfos->fd = open(devInfos->device, O_RDWR | O_NONBLOCK, 0);
  if (-1 == devInfos->fd) {
    fprintf(stderr, "[cap%d] Cannot open '%s': %d, %s\n", devInfos->index, devInfos->device, errno, strerror(errno));
    exit(EXIT_FAILURE);
  }
  fprintf(stderr, "[cap%d] Opened V4L2 device: %s\n", devInfos->index, devInfos->device);
  struct v4l2_capability cap;
  struct v4l2_cropcap cropcap;
  struct v4l2_crop crop;
  struct v4l2_format fmt;
  unsigned int min;
  if (-1 == xioctl(devInfos->fd, VIDIOC_QUERYCAP, &cap)) {
    if (EINVAL == errno) {
      fprintf(stderr, "[cap%d] %s is no V4L2 device\n", devInfos->index, devInfos->device);
      exit(EXIT_FAILURE);
    }
    else {
      errno_exit("VIDIOC_QUERYCAP");
    }
  }
  if (!(cap.capabilities & V4L2_CAP_VIDEO_CAPTURE)) {
    fprintf(stderr, "[cap%d] %s is no video capture device\n", devInfos->index, devInfos->device);
    exit(EXIT_FAILURE);
  }
  // Select video input, video standard and tune here.
  CLEAR(cropcap);
  cropcap.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
  if (0 == xioctl(devInfos->fd, VIDIOC_CROPCAP, &cropcap)) {
    crop.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    crop.c = cropcap.defrect; // reset to default
    if (-1 == xioctl(devInfos->fd, VIDIOC_S_CROP, &crop)) {
      switch (errno) {
      case EINVAL:
        // Cropping not supported.
        break;
      default:
        // Errors ignored.
        break;
      }
    }
  } else {
    // Errors ignored.
  }
  CLEAR(fmt);
  fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
  fprintf(stderr, "[cap%d] Forcing format for %s to: %d\n", devInfos->index, devInfos->device, devInfos->force_format);
  if (devInfos->force_format) {
    if (devInfos->force_format == 3) {
      byteScaler = devInfos->force_format;
      fmt.fmt.pix.width = devInfos->startingWidth;
      fmt.fmt.pix.height = devInfos->startingHeight;
      fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_RGB24;
      fmt.fmt.pix.field = V4L2_FIELD_NONE; // V4L2_FIELD_INTERLACED;
    } else if (devInfos->force_format == 2) {
      byteScaler = devInfos->force_format;
      fmt.fmt.pix.width = devInfos->startingWidth;
      fmt.fmt.pix.height = devInfos->startingHeight;
      fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_UYVY;
      fmt.fmt.pix.field = V4L2_FIELD_NONE; // V4L2_FIELD_INTERLACED;
    } else if (devInfos->force_format == 1) {
      byteScaler = devInfos->force_format;
      fmt.fmt.pix.width = devInfos->startingWidth;
      fmt.fmt.pix.height = devInfos->startingHeight;
      fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_GREY;
      fmt.fmt.pix.field = V4L2_FIELD_NONE; // V4L2_FIELD_INTERLACED;
    }
    if (-1 == xioctl(devInfos->fd, VIDIOC_S_FMT, &fmt))
      errno_exit("VIDIOC_S_FMT");
    // Note VIDIOC_S_FMT may change width and height.
  } else {
    // Preserve original settings as set by v4l2-ctl for example
    if (-1 == xioctl(devInfos->fd, VIDIOC_G_FMT, &fmt))
      errno_exit("VIDIOC_G_FMT");
  }
  // Buggy driver paranoia.
  min = fmt.fmt.pix.width * 2;
  if (fmt.fmt.pix.bytesperline < min)
    fmt.fmt.pix.bytesperline = min;
  min = fmt.fmt.pix.bytesperline * fmt.fmt.pix.height;
  if (fmt.fmt.pix.sizeimage < min)
    fmt.fmt.pix.sizeimage = min;

  CLEAR(devInfos->req);
  devInfos->req.count = 4;
  devInfos->req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
  devInfos->req.memory = V4L2_MEMORY_MMAP;
  if (-1 == xioctl(devInfos->fd, VIDIOC_REQBUFS, &devInfos->req)) {
    if (EINVAL == errno) {
      fprintf(stderr, "[cap%d] %s does not support memory mapping\n", devInfos->index, devInfos->device);
      exit(EXIT_FAILURE);
    } else {
      errno_exit("VIDIOC_REQBUFS");
    }
  }
  if (devInfos->req.count < 2) {
    fprintf(stderr, "[cap%d] Insufficient buffer memory on %s\n", devInfos->index, devInfos->device);
    exit(EXIT_FAILURE);
  }
  return 0;
}

int init_dev_stage2(struct buffer*& buffers, struct devInfo*& devInfos) {
  if (!buffers) {
    fprintf(stderr, "[cap%d] Out of memory\n", devInfos->index);
    exit(EXIT_FAILURE);
  }
  for (devInfos->n_buffers = 0; devInfos->n_buffers < devInfos->req.count; ++devInfos->n_buffers) {
    struct v4l2_buffer buf;
    CLEAR(buf);
    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    buf.memory = V4L2_MEMORY_MMAP;
    buf.index = devInfos->n_buffers;
    if (-1 == xioctl(devInfos->fd, VIDIOC_QUERYBUF, &buf))
      errno_exit("VIDIOC_QUERYBUF");
    buffers[devInfos->n_buffers].length = buf.length;
    buffers[devInfos->n_buffers].start = mmap(NULL, buf.length, PROT_READ | PROT_WRITE, MAP_SHARED, devInfos->fd, buf.m.offset);
    if (MAP_FAILED == buffers[devInfos->n_buffers].start)
      errno_exit("mmap");
  }
  // TODO: Implement a more proper way to handle settings in this area regarding if we really need DV timings to be set
  if (devInfos->isTC358743) {
    struct v4l2_dv_timings timings;
    v4l2_std_id std;
    int ret;
    memset(&timings, 0, sizeof timings);
    ret = xioctl(devInfos->fd, VIDIOC_QUERY_DV_TIMINGS, &timings);
    if (ret >= 0) {
      fprintf(stderr, "[cap%d] QUERY_DV_TIMINGS for %s: %ux%ux%d pixclk %llu\n", devInfos->index, devInfos->device, timings.bt.width, timings.bt.height, byteScaler, timings.bt.pixelclock);
      devInfos->startingWidth = timings.bt.width;
      devInfos->startingHeight = timings.bt.height;
      devInfos->startingSize = devInfos->startingWidth * devInfos->startingHeight * byteScaler;
      // Can read DV timings, so set them.
      ret = xioctl(devInfos->fd, VIDIOC_S_DV_TIMINGS, &timings);
      if (ret < 0) {
        fprintf(stderr, "[cap%d] Failed to set DV timings\n", devInfos->index);
        return 1;
      } else {
        double tot_height, tot_width;
        const struct v4l2_bt_timings* bt = &timings.bt;
        tot_height = bt->height + bt->vfrontporch + bt->vsync + bt->vbackporch + bt->il_vfrontporch + bt->il_vsync + bt->il_vbackporch;
        tot_width = bt->width + bt->hfrontporch + bt->hsync + bt->hbackporch;
        devInfos->framerate = (unsigned int)((double)bt->pixelclock / (tot_width * tot_height));
        if (devInfos->framerate < devInfos->targetFramerate) devInfos->targetFramerate = devInfos->framerate;
        devInfos->framerateDivisor = (devInfos->framerate / devInfos->targetFramerate);
        devInfos->frameDelayMicros = (1000000.0 / devInfos->framerate);
        devInfos->frameDelayMillis = (1000.0 / devInfos->framerate);
        devInfos->targetFrameDelayMicros = (1000000.0 / devInfos->framerate) * devInfos->framerateDivisor;
        devInfos->targetFrameDelayMillis = (1000.0 / devInfos->framerate) * devInfos->framerateDivisor;
        int rawInputThroughput = (float)((float)(devInfos->framerate * devInfos->startingSize) / 125000.0F); // Mb/s based on input framerate
        int rawOutputThroughput = ((float)((float)(devInfos->framerate * devInfos->startingSize) / 125000.0F)) / devInfos->framerateDivisor; // Mb/s based on output framerate
        devInfos->realAndTargetRatesMatch = doubles_equal(devInfos->frameDelayMicros, devInfos->targetFrameDelayMicros);
        fprintf(stderr, "[cap%d] device_name: %s, startingWidth: %d, startingHeight: %d, byteScaler: %d, startingSize: %d, framerate(actual): %u, framerateDivisor: %f, targetFramerate: %f, frameDelayMicros: %f, frameDelayMillis: %f, targetFrameDelayMicros: %f, targetFrameDelayMillis: %f, realAndTargetRatesMatch: %d\n",
          devInfos->index, devInfos->device, devInfos->startingWidth, devInfos->startingHeight, byteScaler, devInfos->startingSize, devInfos->framerate, devInfos->framerateDivisor, devInfos->targetFramerate, devInfos->frameDelayMicros, devInfos->frameDelayMillis, devInfos->targetFrameDelayMicros, devInfos->targetFrameDelayMillis, devInfos->realAndTargetRatesMatch);
        fprintf(stderr, "[cap%d] device_name: %s, isTC358743: %d, rawInputThroughput: ~%dMb/~%dMiB/~%dMB/sec, rawOutputThroughput: ~%dMb/~%dMiB/~%dMB/sec\n", devInfos->index, devInfos->device, devInfos->isTC358743, rawInputThroughput, (int)((double)rawInputThroughput / 8.389), rawInputThroughput / 8, rawOutputThroughput, (int)((double)rawOutputThroughput / 8.389), rawOutputThroughput / 8);
      }
    } else {
      memset(&std, 0, sizeof std);
      ret = ioctl(devInfos->fd, VIDIOC_QUERYSTD, &std);
      if (ret >= 0) {
        // Can read standard, so set it.
        ret = xioctl(devInfos->fd, VIDIOC_S_STD, &std);
        if (ret < 0) {
          fprintf(stderr, "[cap%d] Failed to set standard\n", devInfos->index);
          return 1;
        } else {
          // SD video - assume 50Hz / 25fps
          devInfos->framerate = 25;
        }
      }
    }
  } else {
    fprintf(stderr, "[cap%d] Fatal: Only the TC358743 is supported for now. Support for general camera inputs (such as: %s) will need to be added in the future..\nExiting now.\n", devInfos->index, devInfos->device);
    exit(1);
  }
  unsigned int i;
  for (i = 0; i < devInfos->n_buffers; ++i) {
    struct v4l2_buffer buf;
    CLEAR(buf);
    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    buf.memory = V4L2_MEMORY_MMAP;
    buf.index = i;
    if (-1 == xioctl(devInfos->fd, VIDIOC_QBUF, &buf))
      errno_exit("VIDIOC_QBUF");
  }
  devInfos->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
  if (-1 == xioctl(devInfos->fd, VIDIOC_STREAMON, &devInfos->type))
    errno_exit("VIDIOC_STREAMON");
  fprintf(stderr, "[cap%d] Initialized V4L2 device: %s\n", devInfos->index, devInfos->device);
  return 0;
}

int get_frame(struct buffer* buffers, struct devInfo* devInfos) {
  fd_set fds;
  struct timeval tv;
  int r;
  FD_ZERO(&fds);
  FD_SET(devInfos->fd, &fds);
  // Timeout period to wait for device to respond
  tv.tv_sec = 0;
  tv.tv_usec = (suseconds_t)(devInfos->frameDelayMicros * 2.0);
  r = select(devInfos->fd + 1, &fds, NULL, NULL, &tv);
  if (-1 == r) {
    if (EINTR == errno) {
      return 0;
    }
    errno_exit("select");
  }
  if (0 == r) {
    fprintf(stderr, "[cap%d] select timeout\n", devInfos->index);
    shouldLoop.store(false);
    return 1;
  }
  struct v4l2_buffer buf;
  CLEAR(buf);
  buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
  buf.memory = V4L2_MEMORY_MMAP;
  if (-1 == xioctl(devInfos->fd, VIDIOC_DQBUF, &buf)) {
    switch (errno) {
    case EAGAIN:
      fprintf(stderr, "[cap%d] EAGAIN\n", devInfos->index);
      return 0;
    case EIO:
      // fall through
    default:
      fprintf(stderr, "%s error %d, %s\n", "VIDIOC_DQBUF", errno, strerror(errno));
      shouldLoop.store(false);
      return 1;
    }
  }
  assert(buf.index < devInfos->n_buffers);
  std::memcpy(devInfos->outputFrame, (unsigned char*)buffers[buf.index].start, buffers[buf.index].length); // copy frame data to frame buffer
  if (-1 == xioctl(devInfos->fd, VIDIOC_QBUF, &buf))
    errno_exit("VIDIOC_QBUF");
  return 0;
}

int deinit_bufs(struct buffer*& buffers, struct devInfo*& devInfos) {
  for (unsigned int i = 0; i < devInfos->n_buffers; ++i)
    if (-1 == munmap(buffers[i].start, buffers[i].length))
      errno_exit("munmap");
  free(buffers);
  fprintf(stderr, "[cap%d] Uninitialized V4L2 device: %s\n", devInfos->index, devInfos->device);
  if (-1 == close(devInfos->fd))
    errno_exit("close");
  devInfos->fd = -1;
  fprintf(stderr, "[cap%d] Closed V4L2 device: %s\n", devInfos->index, devInfos->device);
  fprintf(stderr, "\n");
  return 0;
}

void did_memory_allocate_correctly(struct devInfo*& devInfos) {
  if (devInfos->outputFrame == NULL) {
    fprintf(stderr, "[cap%d] Fatal: Memory allocation failed of output frame for device: %s..\nExiting now.\n", devInfos->index, devInfos->device);
    exit(1);
  }
}

int init_vars(struct devInfo*& devInfos, struct buffer*& bufs, const int force_format, const double targetFramerate, const bool isTC358743, const bool /*isThermalCamera*/, const char* dev_name, int index) {
  devInfos = (devInfo*)calloc(1, sizeof(*devInfos));
  devInfos->device = (char*)calloc(strlen(dev_name)+1, sizeof(char));
  strcpy(devInfos->device, dev_name);
  devInfos->frame_number = 0;
  devInfos->framerate = 30;
  devInfos->framerateDivisor = 1;
  devInfos->startingWidth = defaultWidth;
  devInfos->startingHeight = defaultHeight;
  devInfos->startingSize = (devInfos->startingWidth * devInfos->startingHeight * byteScaler);
  devInfos->force_format = force_format;
  devInfos->targetFramerate = targetFramerate;
  devInfos->fd = -1;
  devInfos->isTC358743 = isTC358743;
  devInfos->index = index;

  // Stage1 uses the passed 'bufs' reference name; call correctly for each device
  init_dev_stage1(bufs, devInfos);
  bufs = (buffer*)calloc(devInfos->req.count, sizeof(*bufs));
  init_dev_stage2(bufs, devInfos);
  devInfos->outputFrame = (unsigned char*)calloc((devInfos->startingWidth * devInfos->startingHeight * byteScaler), sizeof(unsigned char)); // allocate memory for frame buffer
  did_memory_allocate_correctly(devInfos);
  return 0;
}

void cleanup_vars() {
  deinit_bufs(buffersMain, devInfoMain);
  if (isDualInput) deinit_bufs(buffersAlt, devInfoAlt);

  // Close network sockets
  for (int fd : client_fds) {
    close(fd);
  }
  client_fds.clear();
  if (listen_fd >= 0) {
    close(listen_fd);
    listen_fd = -1;
  }
}

void configure_main(struct devInfo*& deviMain, struct buffer*& bufMain, struct devInfo*& deviAlt, struct buffer*& bufAlt) {
  fprintf(stderr, "[main] Initializing..\n");
  // allocate memory for structs
  init_vars(deviMain, bufMain, 3, allDevicesTargetFramerate, true, true, devNames[0].c_str(), 0);
  if (isDualInput) init_vars(deviAlt, bufAlt, 3, allDevicesTargetFramerate, true, true, devNames[1].c_str(), 1);
  shouldLoop.store(true);
  numPixels = devInfoMain->startingWidth * devInfoMain->startingHeight;
  usleep(1000);
  fprintf(stderr, "\n");
}

int main(const int argc, char** argv) {
  // Parse options and devices first
  parse_cli_or_die(argc, (const char**)argv);

  // Create a window to display the results
  configure_main(devInfoMain, buffersMain, devInfoAlt, buffersAlt);

  // Setup TCP server
  listen_fd = setup_server_socket(listenPort);
  if (listen_fd < 0) {
    fprintf(stderr, "[main] Failed to create TCP listening socket on port %d\n", listenPort);
    cleanup_vars();
    return 1;
  }

  MicroStopwatch sw;
  usleep(1000);

  // Capture and ignore some frames for about 1/2 seconds due to strange issue with first frame(s)
  for (int i = 0; i < 60; i++) {
    accept_new_clients(); // allow clients to connect early
    if (isDualInput) {
      background_task_cap_main = std::async(std::launch::async, get_frame, buffersMain, devInfoMain);
      background_task_cap_alt = std::async(std::launch::async, get_frame, buffersAlt, devInfoAlt);
      background_task_cap_main.wait();
      background_task_cap_alt.wait();
    } else {
      background_task_cap_main = std::async(std::launch::async, get_frame, buffersMain, devInfoMain);
      background_task_cap_main.wait();
    }
  }

  fprintf(stderr, "\n[main] Starting main loop now\n");
  while (shouldLoop) {
    accept_new_clients(); // non-blocking accept of new clients

    if (!devInfoMain->realAndTargetRatesMatch) sw.start();
    background_task_cap_main = std::async(std::launch::async, get_frame, buffersMain, devInfoMain);
    background_task_cap_main.wait();

    // Send the captured frame to all connected TCP clients
    broadcast_frame(devInfoMain->outputFrame, (size_t)devInfoMain->startingSize);
    //fprintf(stderr, "%u\n", (size_t)devInfoMain->startingSize);

    if (!devInfoMain->realAndTargetRatesMatch) {
      double us = devInfoMain->targetFrameDelayMicros - sw.elapsedMicros();
      if (us > 0) usleep((useconds_t)us);
    }
  }

  usleep(1000000);
  cleanup_vars();
  return 0;
}
